<html>
<head>
<meta charset="UTF-8">
<title>Simulation</title>
</head>
<script type="text/javascript" src="matter.js"></script>
<script src="decomp.js" type="text/javascript"></script>
<script type="text/json" src="input.json"></script>
<script type="text/javascript">

var HEIGHT = 600;

function Start() {

  function create_cross_bar(center, radius, phi)
  {
    var vertices = [];
    for(var i = 0; i <= Math.PI/2.0; i += Math.PI/180.0)
    {
      x_ = center.x + (radius+1) * Math.cos(phi+i)
      y_ = center.y + (radius+1) * Math.sin(phi+i)
      vertices.push({x:x_,y:HEIGHT - y_});
    }

    for(var i = Math.PI/2.0; i > 0; i -= Math.PI/180)
    {
      x_ = center.x + (radius-1) * Math.cos(phi+i)
      y_ = center.y + (radius-1) * Math.sin(phi+i)
      vertices.push({x:x_,y: HEIGHT - y_});
    }

    var bar = Matter.Body.create({
      position: Matter.Vertices.centre(vertices),
      vertices: vertices,
      isStatic: false
    });

    //Matter.Body.setMass(bar, 0.1)

    return bar;
  }

  function create_box(left_bottom, width, height, mass){
    var center = {x:left_bottom.x + width/2.0, y: HEIGHT-left_bottom.y-height/2.0}
    var box = Bodies.rectangle(left_bottom.x, HEIGHT-left_bottom.y, width, height, { position: center});

    Matter.Body.setMass(box, box.area * 10)
    return box;
  }

  // Hang bar to ceil at a given position
  function hang_bar_to_ceil(composite, bar, center, radius, phi, alpha, ceil_position){
    centroid = Matter.Vertices.centre(bar.vertices)
               //{x: center.x + (radius / Math.sqrt(2)) * Math.cos(phi+Math.PI/4),
               //y: HEIGHT - (center.y + (radius / Math.sqrt(2)) * Math.sin(phi+Math.PI/4) )}

    hanging_point = {x: center.x + (radius) * Math.cos(phi+alpha),
                     y: HEIGHT - (center.y + (radius) * Math.sin(phi+alpha) )}

    offset = { x : hanging_point.x - centroid.x, y : hanging_point.y - centroid.y};
    constraint = Constraint.create({
                          bodyB: bar,
                          pointA: ceil_position,
                          pointB: offset,
                          stiffness: 0.5
                      })
    Composite.add(composite,constraint);
  }

  // Hang bar2 to the left side of bar1
  function hang_bar_to_bar_left(composite,
                         bar1, center1, radius1, phi1,
                         bar2, center2, radius2, phi2, alpha2 ){
    balance_point = { x: center2.x + radius2 * Math.cos(phi2+alpha2),
                      y: HEIGHT - (center2.y + radius2 * Math.sin(phi2+alpha2)) };
    left_point    = { x: center1.x + radius1 * Math.cos(phi1+Math.PI/2),
                      y: HEIGHT - (center1.y + radius1 * Math.sin(phi1+Math.PI/2)) }

    centroid1 = Matter.Vertices.centre(bar1.vertices)

    centroid2 = Matter.Vertices.centre(bar2.vertices)

    point_a = {x : left_point.x - centroid1.x, y : left_point.y - centroid1.y };
    point_b = {x : balance_point.x - centroid2.x, y : balance_point.y - centroid2.y };

    constraint = Constraint.create({
                          bodyA: bar1,
                          bodyB: bar2,
                          pointA: point_a,
                          pointB: point_b,
                          stiffness: 0.5
                      })

    Composite.add(composite,constraint);
  }

  // Hang bar2 to the right side of bar1
  function hang_bar_to_bar_right(composite,
                         bar1, center1, radius1, phi1,
                         bar2, center2, radius2, phi2, alpha2 ){
    balance_point = { x: center2.x + radius2 * Math.cos(phi2+alpha2),
                      y: HEIGHT - (center2.y + radius2 * Math.sin(phi2+alpha2)) };
    right_point    = { x: center1.x + radius1 * Math.cos(phi1),
                      y: HEIGHT - (center1.y + radius1 * Math.sin(phi1)) }

    centroid1 = Matter.Vertices.centre(bar1.vertices)

    centroid2 = Matter.Vertices.centre(bar2.vertices)

    point_a = {x : right_point.x - centroid1.x, y : right_point.y - centroid1.y };
    point_b = {x : balance_point.x - centroid2.x, y : balance_point.y - centroid2.y };

    constraint = Constraint.create({
                          bodyA: bar1,
                          bodyB: bar2,
                          pointA: point_a,
                          pointB: point_b,
                          stiffness: 0.5
                      })

    Composite.add(composite,constraint);
  }

  // Hang an object to the left side of a given bar
  // hanging_offset is the offset vector from center of the object to the hanging point
  function hang_object_to_bar_left(composite,
                         bar, center, radius, phi,
                         object, hanging_offset){

    left_point    = { x: center.x + radius * Math.cos(phi+Math.PI/2),
                      y: HEIGHT - (center.y + radius * Math.sin(phi+Math.PI/2)) }

    centroid = Matter.Vertices.centre(bar.vertices)

    point_a = {x : left_point.x - centroid.x, y : left_point.y - centroid.y };

    constraint = Constraint.create({
                          bodyA: bar,
                          bodyB: object,
                          pointA: point_a,
                          pointB: hanging_offset,
                          stiffness: 0.5
                      })
    Composite.add(composite,constraint);
  }

  // Hang an object to the right side of a given bar
  // hanging_offset is the offset vector from center of the object to the hanging point
  function hang_object_to_bar_right(composite,
                         bar, center, radius, phi,
                         object, hanging_offset){

    right_point    = { x: center.x + radius * Math.cos(phi),
                      y: HEIGHT - (center.y + radius * Math.sin(phi)) }

    centroid = Matter.Vertices.centre(bar.vertices)

    point_a = {x : right_point.x - centroid.x, y : right_point.y - centroid.y };

    constraint = Constraint.create({
                          bodyA: bar,
                          bodyB: object,
                          pointA: point_a,
                          pointB: hanging_offset,
                          stiffness: 0.5
                      })
    Composite.add(composite,constraint);
  }

  // module aliases
  var Engine = Matter.Engine,
      Render = Matter.Render,
      World = Matter.World,
      Body   = Matter.Body,
      Bodies = Matter.Bodies,
      Vertices = Matter.Vertices,
      Composite = Matter.Composite,
      Composites = Matter.Composites,
      Constraint = Matter.Constraint;

  // create an engine
  var engine = Engine.create();

  // create a renderer
  var render = Render.create({
      element: document.body,
      engine: engine
  });


  // create two boxes and a ground
  var boxA = create_box({x:100, y:150}, 10, 20);
  var boxB = create_box({x:290, y:150}, 40, 80);
  var cross_bar = create_cross_bar({x:200,y:200}, 100, Math.PI/4);

  var boxC = create_box({x:300, y:150}, 40, 80);
  var boxD = create_box({x:490, y:150}, 80, 80);

  //Body.setMass(boxA, 50)
  //Body.setMass(boxB, 10)

  var cross_bar2 = create_cross_bar({x:400,y:200}, 100, Math.PI/4);

  var cross_bar3 = create_cross_bar({x:300,y:300}, 200, Math.PI/4);

  //var ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true });

  hanging_mobile_composite = Composite.create();

  //hang_bar_to_ceil(hanging_mobile_composite, cross_bar, {x:200,y:200}, 100, Math.PI/4, Math.PI/4.0, {x:200, y:100});
  hang_object_to_bar_left(hanging_mobile_composite, cross_bar, {x:200,y:200}, 100, Math.PI/4.0, boxA, {x:0,y:-10})
  hang_object_to_bar_right(hanging_mobile_composite, cross_bar, {x:200,y:200}, 100, Math.PI/4.0, boxB, {x:0,y:-40})

  //hang_bar_to_ceil(hanging_mobile_composite, cross_bar2, {x:400,y:200}, 100, Math.PI/4, Math.PI/4.0, {x:400, y:100});
  hang_object_to_bar_left(hanging_mobile_composite, cross_bar2, {x:400,y:200}, 100, Math.PI/4.0, boxC, {x:0,y:-40})
  hang_object_to_bar_right(hanging_mobile_composite, cross_bar2, {x:400,y:200}, 100, Math.PI/4.0, boxD, {x:0,y:-40})

  hang_bar_to_ceil(hanging_mobile_composite, cross_bar3, {x:300,y:300}, 200, Math.PI/4, Math.PI/4.0 - 0.21, {x:400, y:50})
  hang_bar_to_bar_left(hanging_mobile_composite,
                       cross_bar3, {x:300,y:300}, 200, Math.PI/4,
                       cross_bar, {x:200,y:200}, 100, Math.PI/4.0, Math.PI/4.0 + 0.1 )
  hang_bar_to_bar_right(hanging_mobile_composite,
                       cross_bar3, {x:300,y:300}, 200, Math.PI/4,
                       cross_bar2, {x:400,y:200}, 100, Math.PI/4.0, Math.PI/4.0 + 0.05 )

  World.add(engine.world, hanging_mobile_composite);

  // add all of the bodies to the world
  World.add(engine.world, [boxA, boxB, cross_bar, boxC, boxD, cross_bar2, cross_bar3]);

  // run the engine
  Engine.run(engine);

  // run the renderer
  Render.run(render);
}
</script>
<body onload='Start()'>
</body>
</html>
